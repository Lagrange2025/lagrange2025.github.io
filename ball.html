<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>台球游戏</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background: linear-gradient(45deg, #d0e1f9, #b0c1d7);
            overflow: hidden;
            flex-direction: column;
        }
        canvas {
            border: 5px solid #444;
            background-color: #3e8e41;
            margin-bottom: 20px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        #scoreboard {
            font-size: 20px;
            color: white;
            margin: 10px 0;
            background-color: rgba(0, 0, 0, 0.6);
            padding: 10px;
            border-radius: 10px;
        }
        .control-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #directionCanvas {
            width: 150px;
            height: 150px;
            margin: 10px;
        }
        #powerSlider {
            width: 300px;
            margin: 10px;
        }
        .power-value {
            color: white;
            font-weight: bold;
            font-size: 16px;
        }
    </style>
</head>
<body>
    <div id="scoreboard">
        <div>Player 1 Score: <span id="score1">0</span></div>
        <div>Player 2 Score: <span id="score2">0</span></div>
        <div>Turn: <span id="turn">Player 1</span></div>
        <div>Game Status: <span id="gameStatus">In Progress</span></div>
    </div>
    <canvas id="poolTable" width="800" height="400"></canvas>
    
    <div class="control-container">
        <canvas id="directionCanvas"></canvas>
        <input id="powerSlider" type="range" min="0" max="100" value="50">
        <div class="power-value">Power: <span id="powerValue">50</span></div>
    </div>

    <script>
        const canvas = document.getElementById('poolTable');
        const ctx = canvas.getContext('2d');
        const directionCanvas = document.getElementById('directionCanvas');
        const directionCtx = directionCanvas.getContext('2d');
        const tableWidth = canvas.width;
        const tableHeight = canvas.height;

        const ballRadius = 10;
        const friction = 0.98;
        const maxSpeed = 10;
        let turn = 1;  // Player 1 starts
        let player1Score = 0;
        let player2Score = 0;
        let gameStatus = 'In Progress';  // Game state
        let ballsRemaining = 8;  // 8 balls in the game, including the 8 ball.

        // Balls: 8 balls + cue ball
        const cueBall = { x: tableWidth / 2, y: tableHeight / 2, vx: 0, vy: 0, color: 'white', id: 'cue' };
        const balls = [
            { x: 150, y: 200, vx: 0, vy: 0, color: 'red', id: '1' },
            { x: 250, y: 200, vx: 0, vy: 0, color: 'blue', id: '2' },
            { x: 350, y: 200, vx: 0, vy: 0, color: 'green', id: '3' },
            { x: 450, y: 200, vx: 0, vy: 0, color: 'yellow', id: '4' },
            { x: 550, y: 200, vx: 0, vy: 0, color: 'purple', id: '5' },
            { x: 650, y: 200, vx: 0, vy: 0, color: 'orange', id: '6' },
            { x: 750, y: 200, vx: 0, vy: 0, color: 'brown', id: '7' },
            { x: 400, y: 100, vx: 0, vy: 0, color: 'black', id: '8' } // 8 ball
        ];

        // Load sound effects
        const hitSound = new Audio('hit.mp3');
        const pocketSound = new Audio('pocket.mp3');
        const foulSound = new Audio('foul.mp3');

        let selectedAngle = 0;  // Initial angle for the direction
        let powerLevel = 50;  // Initial power level

        // Draw ball function
        function drawBall(ball) {
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ballRadius, 0, Math.PI * 2);
            ctx.fillStyle = ball.color;
            ctx.fill();
            ctx.closePath();
        }

        // Draw the pool table with pockets
        function drawTable() {
            ctx.clearRect(0, 0, tableWidth, tableHeight);

            // Background with gradient
            const gradient = ctx.createLinearGradient(0, 0, tableWidth, tableHeight);
            gradient.addColorStop(0, '#006400');
            gradient.addColorStop(1, '#4caf50');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, tableWidth, tableHeight);

            // Draw pockets
            ctx.fillStyle = 'black';
            const pockets = [
                { x: 0, y: 0 }, { x: tableWidth, y: 0 },
                { x: 0, y: tableHeight }, { x: tableWidth, y: tableHeight },
                { x: tableWidth / 2, y: 0 }, { x: tableWidth / 2, y: tableHeight },
                { x: 0, y: tableHeight / 2 }, { x: tableWidth, y: tableHeight / 2 }
            ];
            pockets.forEach(pocket => {
                ctx.beginPath();
                ctx.arc(pocket.x, pocket.y, 20, 0, Math.PI * 2);
                ctx.fill();
                ctx.closePath();
            });
        }

        // Draw direction control
        function drawDirectionControl() {
            const radius = 60;
            directionCtx.clearRect(0, 0, directionCanvas.width, directionCanvas.height);
            directionCtx.beginPath();
            directionCtx.arc(75, 75, radius, 0, Math.PI * 2);
            directionCtx.fillStyle = '#333';
            directionCtx.fill();
            directionCtx.lineWidth = 5;
            directionCtx.strokeStyle = '#000';
            directionCtx.stroke();

            // Draw direction arrow
            const arrowX = 75 + Math.cos(selectedAngle) * radius;
            const arrowY = 75 + Math.sin(selectedAngle) * radius;
            directionCtx.beginPath();
            directionCtx.moveTo(75, 75);
            directionCtx.lineTo(arrowX, arrowY);
            directionCtx.stroke();
        }

        // Handle mouse or touch input to select angle
        let isSelectingAngle = false;
        directionCanvas.addEventListener('mousedown', (e) => {
            isSelectingAngle = true;
            updateDirection(e);
        });

        directionCanvas.addEventListener('mousemove', (e) => {
            if (isSelectingAngle) {
                updateDirection(e);
            }
        });

        directionCanvas.addEventListener('mouseup', () => {
            isSelectingAngle = false;
        });

        function updateDirection(e) {
            const rect = directionCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left - 75;
            const y = e.clientY - rect.top - 75;
            selectedAngle = Math.atan2(y, x);
            drawDirectionControl();
        }

        // Move the ball and apply friction
        function moveBall(ball) {
            ball.x += ball.vx;
            ball.y += ball.vy;

            ball.vx *= friction;
            ball.vy *= friction;

            const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
            if (speed > maxSpeed) {
                ball.vx = (ball.vx / speed) * maxSpeed;
                ball.vy = (ball.vy / speed) * maxSpeed;
            }
        }

        // Collision detection
        function collision(ball1, ball2) {
            const dx = ball1.x - ball2.x;
            const dy = ball1.y - ball2.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < ballRadius * 2) {
                const angle = Math.atan2(dy, dx);
                const speed1 = Math.sqrt(ball1.vx * ball1.vx + ball1.vy * ball1.vy);
                const speed2 = Math.sqrt(ball2.vx * ball2.vx + ball2.vy * ball2.vy);

                ball1.vx = speed2 * Math.cos(angle);
                ball1.vy = speed2 * Math.sin(angle);
                ball2.vx = speed1 * Math.cos(angle + Math.PI);
                ball2.vy = speed1 * Math.sin(angle + Math.PI);
                hitSound.play(); // Play hit sound
            }
        }

        // Boundary collision handling
        function boundaryCollision(ball) {
            if (ball.x + ballRadius > tableWidth || ball.x - ballRadius < 0) {
                ball.vx = -ball.vx;
                ball.x = ball.x < ballRadius ? ballRadius : (ball.x > tableWidth - ballRadius ? tableWidth - ballRadius : ball.x);
            }
            if (ball.y + ballRadius > tableHeight || ball.y - ballRadius < 0) {
                ball.vy = -ball.vy;
                ball.y = ball.y < ballRadius ? ballRadius : (ball.y > tableHeight - ballRadius ? tableHeight - ballRadius : ball.y);
            }
        }

        // Check if ball goes into pocket
        function checkPocket(ball) {
            return ball.x < 0 || ball.x > tableWidth || ball.y < 0 || ball.y > tableHeight;
        }

        // Pocket ball logic
        function pocketBall(ball) {
            pocketSound.play(); // Play pocket sound
            ballsRemaining--;
            if (ball.id === '8') {
                gameStatus = 'Player ' + turn + ' Wins!';
                updateGameStatus();
            } else {
                if (turn === 1) {
                    player1Score++;
                } else {
                    player2Score++;
                }
                updateScore();
            }

            // Reset ball position for simplicity
            ball.x = Math.random() * (tableWidth - 50) + 50;
            ball.y = Math.random() * (tableHeight - 50) + 50;
            ball.vx = 0;
            ball.vy = 0;
        }

        // Update score on the screen
        function updateScore() {
            document.getElementById('score1').textContent = player1Score;
            document.getElementById('score2').textContent = player2Score;
        }

        // Update game status on the screen
        function updateGameStatus() {
            document.getElementById('gameStatus').textContent = gameStatus;
        }

        // Switch turns
        function switchTurn() {
            turn = turn === 1 ? 2 : 1;
            document.getElementById('turn').textContent = 'Player ' + turn;
        }

        // Draw function
        function draw() {
            drawTable();
            drawBall(cueBall);
            balls.forEach(drawBall);

            balls.forEach(moveBall);
            balls.forEach(ball => collision(cueBall, ball));

            balls.forEach(boundaryCollision);

            balls.forEach(ball => {
                if (checkPocket(ball)) {
                    pocketBall(ball);
                }
            });

            requestAnimationFrame(draw);
        }

        // Power slider functionality
        document.getElementById('powerSlider').addEventListener('input', function () {
            powerLevel = this.value;
            document.getElementById('powerValue').textContent = powerLevel;
        });

        // Shoot ball based on direction and power
        canvas.addEventListener('click', () => {
            const speed = (powerLevel / 100) * maxSpeed;
            cueBall.vx = Math.cos(selectedAngle) * speed;
            cueBall.vy = Math.sin(selectedAngle) * speed;
            switchTurn(); // Change turn after shooting
        });

        draw(); // Start the game loop
    </script>
</body>
</html>